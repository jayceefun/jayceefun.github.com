<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Jaycee's Blog]]></title>
  <link href="http://jayceefun.github.io/atom.xml" rel="self"/>
  <link href="http://jayceefun.github.io/"/>
  <updated>2013-09-13T11:44:19+08:00</updated>
  <id>http://jayceefun.github.io/</id>
  <author>
    <name><![CDATA[Jaycee Fun]]></name>
    <email><![CDATA[fanjinchen@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Mongoose 同时建立多个数据库连接]]></title>
    <link href="http://jayceefun.github.io/blog/2013/08/27/mongoose_multi_dbs/"/>
    <updated>2013-08-27T14:03:00+08:00</updated>
    <id>http://jayceefun.github.io/blog/2013/08/27/mongoose_multi_dbs</id>
    <content type="html"><![CDATA[<p>此篇用于备忘, 最近要拆分数据库, 但是保留用户部分共享, 因此会用到一个项目的代码连接多个数据库的情况, 以前用的是</p>

<blockquote><pre><code>   mongoose.connect()
</code></pre></blockquote>

<p>用这个建立的数据库连接, 只能连接一个数据库, 要想同时连接多个, 需要用下面这个:</p>

<blockquote><pre><code>   mongoose.createConnection()
</code></pre></blockquote>

<p>就现在项目的逻辑来说, demo大致如下:</p>

<blockquote><pre><code>   //首先创建两个数据库连接
   var mongoose = require('mongoose');
   var config = require('config');
   var conn1 = mongoose.createConnection(config.db1);
   var conn2 = mongoose.createConnection(config.db2);
</code></pre></blockquote>

<p>创建模型测试:</p>

<blockquote><pre><code>  //创建两个用户模型
  var Schema = mongoose.schema;        
  var UserSchema1 = new Schema({
      nickname: String,
      age: Number,
      email: String,
  });

  var UserSchema2 = new Schema({
      nickname: String,
      age: Number,
      email: String,
  });

  //再来, 我们创建两个不同连接的module,
  var User1 = conn1.model('User', UserSchema1);
  var User2 = conn2.model('User', UserSchema2);

  //接下来, 写两个测试函数看看结果: 
  function save1() {
      new User1({
          nickname: 'one',
          age: 8,
          email: 'qiaoker@hello.com',
      }).save(function (err, user) {
          if (err) {
              console.error(err.toString());
          } else {
              console.log('===== user1 ========');
              console.log(user);
          }
      });
  }
  function save2() {
      new User2({
          nickname: 'two',
          age: 3,

      }).save(function (err, user) {
          if (err) {
              console.error(err.toString());
          } else {
              console.log('===== user2 ========');
              console.log(user);
          }
      });
  }
</code></pre>

<p>经测试, 两个函数分别生成了各自的数据库和集合, 实现了业务需要, 即使用指定数据库中的模型, 唯一要注意的是在使用不同的数据库的模型时, 要知道自己在用哪个连接, 连接对象的名字要起得清晰.</p></blockquote>

<p>最后补充一个最近总要用到的array类型字段的筛选方法: elemMatch方法, 这个方法mongoose官方文档写的很省略.. 基本上没明白是干嘛用的, 无奈我去看了mongodb的对应方法, 才知道原来是筛选符合条件的array字段的doc用的, 大概的用法如下</p>

<blockquote><pre><code>   Model.where('friends').elemMatch({sb: '2b'}).execFind(callback);
   // 上面的查询语句可以筛选出friends这个数组字段中拥有{2b: '2b'}这个元素的所有的doc. 
</code></pre></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[javascript中的参数传递问题]]></title>
    <link href="http://jayceefun.github.io/blog/2013/08/27/firstone/"/>
    <updated>2013-08-27T14:03:00+08:00</updated>
    <id>http://jayceefun.github.io/blog/2013/08/27/firstone</id>
    <content type="html"><![CDATA[<blockquote><p>这是一个非常容易混搅的经典问题, 关于js中的参数传递, 到底是按值还是按引用呢? 最近在工作中确实的遇到了这样的问题, 所以就写篇blog拿出来818好了, 当做复习了.</p>

<p>关于这个问题, 初学者很容易踏入这样一个误区, 那就是引用类型是按引用传递, 普通类型按值传递:</p>

<h4>注意: 这是不正确的, 根据javascript高级程序第三版中的严格定义, 可以知道: javascript中的所有参数传递都是按值传递的.</h4>

<p>的确, 从行为上来看, 好像真的是这样, 下面来看看书中的例子:</p></blockquote>

<pre><code>    function addTen(num) {
        num += 10;
        return num;
    }

    var count = 20;
    var result = addTen(count);
    console.log(count);    //20, 木有变化
    console.log(result);    //30, 它变态了:P

    上面这个程序很好理解, 普通类型嘛, 我们再来看看普遍认为的按引用传递的情况:

    function setName(obj) {
        obj.name = "jaycee";
    }

    var person = new Object();
    setName(person);
    console.log(person.name);     //"jaycee", 也没什么不对的;

    下面是重点了, 理解下面这个段代码是很重要的, 它说明了js中参数传递的本质是按值的:

    function setName(obj) {
        obj.name = "jaycee";
        obj = new Object();
        obj.name = "hippo";
    }

    var person = new Object();
    setName(person);
    console.log(person.name);    //"jaycee", 出现了一些疑惑, 也是最需要好好思考的地方
</code></pre>

<blockquote><p>从上面的最后那段代码我们可以看到, 在setName()方法中, 我们在对传入的obj赋值后, new了一个新的对象, 并赋给了obj, 如果person是按引用传递的, 那么person就回自动被修改为指向其name属性值为hippo的新对象. 但是当我们访问person.name时, 却任然得到了name属性值为jaycee的结果, 说明即使在函数内部修改了参数的值, 但原始的引用仍保持不变. 当函数在内部重写obj时, 这个变量引用的就是一个局部的对象了. 而这个对象会在函数执行完毕后立即被销毁.</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试2]]></title>
    <link href="http://jayceefun.github.io/blog/2013/08/27/test2/"/>
    <updated>2013-08-27T11:02:00+08:00</updated>
    <id>http://jayceefun.github.io/blog/2013/08/27/test2</id>
    <content type="html"><![CDATA[<blockquote><p>测试第二篇, it&rsquo;s cool :)</p></blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[测试1]]></title>
    <link href="http://jayceefun.github.io/blog/2013/08/27/test1/"/>
    <updated>2013-08-27T10:45:00+08:00</updated>
    <id>http://jayceefun.github.io/blog/2013/08/27/test1</id>
    <content type="html"><![CDATA[<blockquote><p>测试第一篇 :P</p>

<pre><code>   # 来段代码试试
   puts 'hello, world.'
</code></pre></blockquote>
]]></content>
  </entry>
  
</feed>
